---
output: html_document
editor_options: 
  chunk_output_type: console
---
**Select LDNA SNPs**
===


```{r}
library(dplyr)
library(plyr)
library(gdata)
library(igraph)
devtools::install_github("petrikemppainen/LDna")
library(LDna)
```


```{r}
ldna = read.table("na_ddGBS50.5.7_LD_infile")
ldeu = read.table("eu_ddGBS50.5.7_LD_infile")
ldau = read.table("au_ddGBS50.5.7_LD_infile")
```


```{r}
ldna$SNPID = paste(ldna[,1],ldna[,2],sep = "__")
SNP_na <- read.table("xtx_1000_99_allwind/xtxna_1000-1000_top99_allwinds_SNPinfo", header=T)
SNP_na$windID  <- paste0(SNP_na$contig, "__", SNP_na$win.start)
wind_overlap = read.table("overlapallmethods.txt", header=T)
```

```{r}
wind_overlaptop_na_2m = wind_overlap[which(wind_overlap$total_na>1),] #outlier windows in 2 or more methods
wind_overlaptop_na_1m = wind_overlap[which(wind_overlap$total_na>0),] #outlier windows in 1 or more methods

topSNP_na_2m = semi_join(SNP_na, wind_overlaptop_na_2m, by="windID")
topSNP_na_1m = semi_join(SNP_na, wind_overlaptop_na_1m, by="windID")

topSNP_na_2m$SNPID = paste(topSNP_na_2m$contig, topSNP_na_2m$location,sep="__")
topSNP_na_1m$SNPID = paste(topSNP_na_1m$contig, topSNP_na_1m$location,sep="__")

topSNP_na_2m_rand <- ddply(topSNP_na_2m[which(topSNP_na_2m$myrank>0.99),], ~windID, function(x){ ndf <- x[sample(nrow(x),1), ]})
topSNP_na_1m_rand <- ddply(topSNP_na_1m[which(topSNP_na_1m$myrank>0.99),], ~windID, function(x){ ndf <- x[sample(nrow(x),1), ]})

write.table(topSNP_na_2m_rand, "topSNP_na_2m_rand")
write.table(topSNP_na_1m_rand, "topSNP_na_1m_rand")

#select non-outlier SNPs
nooutl_wind_na = wind_overlap[which(wind_overlap$total_na<1),] #not an outlier window in any method
notopSNP_na = semi_join(SNP_na, nooutl_wind_na, by="windID")
notopSNP_na$SNPID = paste(notopSNP_na$contig, notopSNP_na$location,sep="__")
notopSNP_na_rand <- ddply(notopSNP_na[which(notopSNP_na$myrank<0.99),], ~windID, function(x){ndf <- x[sample(nrow(x),1), ]})
write.table(notopSNP_na_rand, "notopSNP_na_rand")

randsel_na =gdata::combine(topSNP_na_2m_rand,notopSNP_na_rand) #need to detach dplyr
LD_rand_na = semi_join(ldna, randsel_na, by="SNPID") #this will only retain the random SNPs as selected above (>50% missing data will be removed)
```

Based on SNPID
```{r}
#select SNPID and inds
input= LD_rand_na[,c(ncol(LD_rand_na),3:(ncol(LD_rand_na)-1))]

#this is the list of contigs and positions for each genotype
scafpos_good <- as.matrix (input[,1])

#this keeps the columns correct: 
input_good = data.matrix(input[,2:dim(input)[2]])

# Check if R is able to handle the amount of data 2^31 is the maximum extent of each dimension of an array R is able to handle
(nrow(input_good)^2)*3 < 2^31

results_out <- array (NA, c(((nrow (input_good))^2),3))
count = 0

#loop through focal snp
for (i in 1:nrow(input_good)){
#       loop through all SNPs
        for (j in 1:nrow (input_good)){
                if (i != j){
                count <- count + 1
                 results_out[count,3] <- cor (input_good[i,], input_good[j,], use = "pairwise.complete.obs")
                results_out [count,1] <- as.character (scafpos_good[i,1])
                results_out [count,2] <- as.character (scafpos_good[j,1])
                }
        }
}

write.table (results_out[1:count,],"LD_na50_ddgbs_random_results_out",row.names = F, col.names = F, quote = F)
```

```{r}
LDNA <- read.table("LD_na50_ddgbs_random_results_out")
colnames(LDNA) <- c("SNPID","SNPID2","Corr")

randsel_na$SNPID2 = randsel_na$SNPID
LD_allwind_na = inner_join(randsel_na,LDNA, by="SNPID")

plot(sqrt(abs(LD_allwind_na$Corr))~LD_allwind_na$source)

LD_allwind_na$Corrabs = abs(LD_allwind_na$Corr)
anova(lm(sqrt(LD_allwind_na$Corrabs)~LD_allwind_na$source))
```

Turn into matrix #library(igraph)
```{r}
G <- graph.data.frame(LDNA,directed=FALSE)
A <- as_adjacency_matrix(G,names=TRUE,sparse=FALSE,attr = "Corr",type='lower')
write.table(A, "LDrand_mat_NA")
A = read.table("LDrand_mat_NA")

#cannot have NA in data
table(is.na(A))
A[is.na(A)] = 0
#write.table(A, "A", row.names=T)
#A= as.matrix(read.table("A", header = T, row.names = 1))

LDmat=A
b=abs(A)
ldna = LDnaRaw(LDmat)
ldnab = LDnaRaw(b) #I think I need to use this one as negative and positive correlations only depend on the ancestral state (i.e. allele at reference genome)

ldna$clusterfile
ldna$stats
par(mfcol=c(1,2))
clusters1 <- extractClusters(ldna, min.edges = 0, phi = 1)
clusters1
par(mfcol=c(1,2))
clusters2 <- extractClusters(ldna, min.edges = 0, phi = 0.25, rm.COCs=FALSE)
clusters2
summary <- summaryLDna(ldna, clusters2, LDmat)
summary

plotLDnetwork(LDmat=LDmat, option=1, threshold=0.6)
plotLDnetwork(LDmat=b, option=1, threshold=0.40)
plotLDnetwork(LDmat=b, option=1, threshold=0.35)

extractClusters(ldna, min.edges = 1, plot.tree = TRUE, extract=FALSE)
c= extractClusters(ldnab, min.edges = 2, plot.tree = TRUE,  phi = 0.25)
summary <- summaryLDna(ldnab, c, b)
par(mfcol=c(2,3))
plotLDnetwork(ldnab, b, option=2, clusters=c, summary=summary)
```

```{r}
dat <- abs(rho_natop[,c(3:4, 6:25)])  # numerical columns
rownames(dat) <- rho_natop[,26]
dat=t(dat)
a<- hclust(dist(A), method="ward.D2")
b<-hclust(dist(t(dat)), method="ward.D2")
snpsplit_na_all = as.data.frame(cutree(b,4))
snpsplit_na_all$SNPID = rownames(snpsplit_na_all)
colnames(snpsplit_na_all) =c( "cluster","SNPID")

pdf("_Graph/heatmap_NAfull.99abs.pdf")
# Plot heatmap with heatmap.3
heatmap3(dat,
          Colv=as.dendrogram(b),     # Reordered cols
          Rowv=as.dendrogram(a)     # Reordered rows
         ) 
dev.off()
##END SCRIPT##